{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Learn with Shashank","text":"<p>Welcome to Learn with Shashank \u2014 a space where I document my journey of continuous learning and share insights on various topics related to software development and beyond.</p> <p>This is not just a personal archive but an open resource available for anyone eager to learn and explore new concepts. Whether you're a fellow developer, a tech enthusiast, or someone curious about the ever-evolving world of software, you'll find something here that piques your interest!</p>"},{"location":"#about-me","title":"About Me","text":"<p>Hi there! I'm Shashank, a passionate software developer who loves to tinker with code and explore the latest trends in technology. When I'm not building or programming, you'll find me diving into new ideas, tools, and methodologies \u2014 always with a curious mindset.</p> <p>I believe in continuous learning and try to stay up-to-date with the latest in programming, software engineering, and development practices. Whether it's exploring a new framework, learning best coding practices, or understanding architectural patterns, I'm constantly experimenting and improving my craft.</p>"},{"location":"#what-youll-find-here","title":"What You'll Find Here","text":"<p>On this website, I document my journey of learning, coding, and software engineering. You\u2019ll find content that covers:</p> <ul> <li>Developer Learning: Insights into programming languages, frameworks, tools, and best practices.</li> <li>Generic Software Engineering: Broader topics such as system design, architecture, software development methodologies, and more.</li> <li>Miscellaneous: A collection of random thoughts, ideas, and anything else that sparks curiosity!</li> </ul>"},{"location":"#join-the-journey","title":"Join the Journey","text":"<p>I\u2019m excited to share what I learn along the way and invite you to join me. Whether you\u2019re just starting out in the tech world or are a seasoned developer, I hope you\u2019ll find something here to inspire you.</p> <p>Feel free to explore, learn, and contribute your thoughts. Let's grow together in this ever-evolving world of technology!</p>"},{"location":"developer_learning/","title":"Developer Learnings","text":"<p>This section will feature interesting blog posts and concise concepts on key software engineering practices and methodologies. I will share valuable insights from foundational books and various topics that every developer should explore and learn from.</p>"},{"location":"developer_learning/#interesting-blogs","title":"Interesting Blogs","text":"<ul> <li>How to Run a Docker Container on AWS EC2 and Access It Externally</li> </ul>"},{"location":"generic_software_engineering/","title":"Generic Software Engineering","text":"<p>This section covers key concepts and best practices in software engineering. Here, you\u2019ll find detailed notes and insights on foundational books and methodologies that every developer should be familiar with.</p>"},{"location":"generic_software_engineering/#book-summary","title":"Book Summary","text":"<ul> <li>Clean code: Best practices for writing readable, maintainable, and efficient code.</li> <li>Pragmatic Programmer: Essential advice and principles for becoming a more effective and adaptable developer.</li> <li>System Design Interview:  Best practices for designing scalable, reliable, and maintainable systems.</li> </ul>"},{"location":"miscellaneous/","title":"Miscellaneous","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/","title":"Clean Code","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/#introduction","title":"Introduction","text":"<p>\"Clean Code\" is a seminal book in software engineering that emphasizes the importance of writing code that is not only functional but also maintainable, readable, and efficient. Robert C. Martin, also known as \"Uncle Bob,\" provides principles, practices, and case studies to teach developers how to write \"clean\" code. The book is divided into three parts:</p> <ol> <li>Principles, patterns, and best practices.</li> <li>Case studies for cleaning up code.</li> <li>A list of heuristics for writing clean code.</li> </ol>"},{"location":"GeneralSoftwareEngineering/CleanCode/#what-is-clean-code","title":"What is Clean Code?","text":"<p>Clean code is described as simple, direct, and elegant. Martin highlights that clean code:</p> <ul> <li>Reads like prose: It should be understandable without additional explanations.</li> <li>Focuses on one task: Each component should do one thing well.</li> <li>Avoids redundancy: Repeated patterns or logic should be eliminated.</li> <li>Is testable and reliable: Bugs should be easy to spot an</li> </ul> <p>He compares clean code to well-written essays\u2014structured, concise, and free from unnecessary details.</p>"},{"location":"GeneralSoftwareEngineering/CleanCode/#key-principles-of-clean-code","title":"Key Principles of Clean Code","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/#meaningful-names","title":"Meaningful Names","text":"<ul> <li>Purposeful: Variable, function, and class names should reflect their purpose and behavior.</li> <li>Avoid abbreviations: Full words are better for readability.</li> <li>Pronounceable names: Make code easier to discuss with teammates.</li> <li>Consistency: Use consistent naming conventions across the codebase.</li> </ul> <p>Bad Example:</p> <pre><code>int d; // What does 'd' represent?\n</code></pre> <p>Good Example:</p> <pre><code>int daysSinceLastUpdate;\n\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#functions","title":"Functions","text":"<ul> <li> <p>Functions are the building blocks of any codebase. To write clean functions:</p> </li> <li> <p>Keep them small: Functions should ideally be 20 lines or less.</p> </li> <li>Single Responsibility: Each function should do one thing and do it well.</li> <li>Avoid side effects: Functions should not alter global states.</li> <li>Descriptive names: Function names should clearly state their purpose.</li> </ul> <p>Bad Example:</p> <pre><code>void process(int a, int b); // Vague purpose\n</code></pre> <p>Good Example:</p> <pre><code>void processOrder(int orderId, int customerId);\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#comments","title":"Comments","text":"<ul> <li>Martin discourages excessive commenting because comments can become outdated as code changes. Instead:</li> <li>Write self-explanatory code that doesn\u2019t need comments.</li> <li>Use comments sparingly for clarifications or highlighting important decisions.</li> <li>Avoid redundant or misleading comments. Bad Example:</li> </ul> <pre><code>// Increment i by 1\ni = i + 1;\n</code></pre> <p>Good Example:</p> <pre><code>// Use this method for backward compatibility with version 1.0\nupdateLegacyData();\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#error-handling","title":"Error Handling","text":"<ul> <li>Don\u2019t ignore exceptions: Handle errors where they occur.</li> <li>Use custom exceptions: Give specific context to errors.</li> <li>Fail fast: Detect and report errors early.</li> <li>Avoid returning null: It leads to null pointer exceptions. Use objects or default values instead.</li> </ul> <p>Bad Example:</p> <pre><code>if (user == null) {\n    // Ignore the issue\n}\n</code></pre> <p>Good Example:</p> <pre><code>if (user == null) {\n    throw new IllegalArgumentException(\"User cannot be null\");\n}\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#formatting","title":"Formatting:","text":"<p>Consistent formatting improves readability:</p> <ul> <li>Follow an agreed-upon style guide.</li> <li>Use proper indentation and spacing.</li> <li>Group related code together logically.</li> <li>Maintain vertical and horizontal alignment to prevent clutter.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#objects-and-data-structures","title":"Objects and Data Structures","text":"<ul> <li>Objects should hide implementation details and expose only essential methods:</li> <li>Encapsulation: Use private fields and public getters/setters.</li> <li>Avoid getters/setters overuse: Instead, expose meaningful behavior.</li> </ul> <p>Bad Example:</p> <pre><code>user.setFirstName(\"John\");\nuser.setLastName(\"Doe\");\n</code></pre> <p>Good Example:</p> <pre><code>user.updateName(\"John Doe\");\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#unit-testing","title":"Unit Testing","text":"<ul> <li>Testing is a cornerstone of clean code. Good tests:</li> <li>Follow the FIRST principles (Fast, Independent, Repeatable, Self-Validating, and Timely).</li> <li>Cover edge cases and boundary conditions.</li> <li>Help detect bugs early and enforce code reliability.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#classes","title":"Classes","text":"<ul> <li>Keep classes small and focused: Each class should represent a single responsibility.</li> <li>Avoid God Classes: Classes that try to do too much.</li> <li>Follow SOLID principles for maintainable design.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#case-studies-cleaning-code","title":"Case Studies: Cleaning Code","text":"<p>The book provides practical examples of messy code and walks through the process of cleaning it. These case studies emphasize: - Refactoring for simplicity. - Removing unnecessary code. - Breaking large functions into smaller, reusable ones. - Testing after each change to ensure nothing breaks.</p> <p>For example, in one case study, Martin takes a long, convoluted function and breaks it down into smaller helper functions. This process involves:</p> <ul> <li>Identifying chunks of code that perform distinct tasks.</li> <li>Creating descriptive helper functions for these tasks.</li> <li>Removing redundant comments and making variable names more meaningful.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#advanced-topics","title":"Advanced Topics","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/#boundaries","title":"Boundaries","text":"<ul> <li> <p>Managing boundaries involves:</p> </li> <li> <p>Minimizing dependencies between components.</p> </li> <li>Using clear interfaces for communication.</li> <li>Avoiding tight coupling, which makes code harder to modify.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#concurrency","title":"Concurrency","text":"<ul> <li>Writing concurrent code is tricky. Martin advises:<ul> <li>Keep data sharing between threads minimal.</li> <li>Use synchronization mechanisms cautiously.</li> <li>Write tests to simulate multithreaded environments.</li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#refactoring","title":"Refactoring","text":"<ul> <li> <p>Refactoring is a disciplined approach to improving code without changing its behavior. Key strategies include:</p> <ul> <li>Consolidating duplicate logic.</li> <li>Extracting methods or classes.</li> <li>Renaming components for clarity.</li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#clean-code-practices","title":"Clean Code Practices","text":"<ol> <li> <p>The Boy Scout Rule:  Always leave the codebase cleaner than you found it. Even small improvements\u2014like renaming variables or breaking down functions\u2014make a big difference over time.</p> </li> <li> <p>Avoid Premature Optimization: Focus on clarity and correctness before optimizing code. Premature optimization often leads to complex, unreadable code.</p> </li> <li> <p>Code Reviews: Engage in peer reviews to ensure code quality and share knowledge within the team.</p> </li> <li> <p>Continuous Improvement: Treat clean code as a continuous journey, not a one-time effort. Regularly revisit and refine your code.</p> </li> </ol>"},{"location":"GeneralSoftwareEngineering/CleanCode/#the-clean-code-mindset","title":"The Clean Code Mindset","text":"<p>Martin stresses that clean code is as much about mindset as it is about practices:</p> <ul> <li>Strive for craftsmanship and take pride in your work.</li> <li>Advocate for simplicity and clarity, even under deadlines.</li> <li>Understand that writing clean code may take more effort initially, but it pays off in the long run through easier maintenance and fewer bugs.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#conclusion","title":"Conclusion","text":"<p>\"Clean Code\" is not just a technical manual but also a philosophy. It encourages developers to think critically about how they write and structure their code. The principles in the book aim to make codebases easier to understand, debug, and extend\u2014qualities that are essential in agile and collaborative environments.</p> <p>By adopting the practices outlined in \"Clean Code,\" developers can create software that stands the test of time, benefiting their teams and the broader community.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/","title":"The Pragmatic Programmer","text":""},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#introduction","title":"Introduction","text":"<p>\"The Pragmatic Programmer\" is a foundational book for software developers, emphasizing the mindset and habits necessary for effective, long-term growth in the field. Hunt and Thomas provide actionable advice on coding, debugging, project management, and professional development. The book is structured into a series of short, insightful lessons, organized into 8 major chapters.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#a-pragmatic-philosophy","title":"A Pragmatic Philosophy","text":"<ul> <li> <p>The authors introduce the pragmatic programmer mindset:</p> </li> <li> <p>Be responsible: Own your decisions, code quality, and the impact on the project.</p> </li> <li>Continuously learn: Stay curious and adaptable.</li> <li>Think critically: Avoid assumptions and validate ideas with evidence.</li> </ul>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#key-concepts","title":"Key concepts:","text":"<ul> <li>The Broken Window Theory: Fix small issues (e.g., bad code, tech debt) early to prevent a cascading decline in quality.</li> <li>Be a catalyst for change: Suggest improvements and help your team embrace better practices.</li> </ul>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#a-pragmatic-approach","title":"A Pragmatic Approach","text":""},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#dry-dont-repeat-yourself","title":"DRY (Don\u2019t Repeat Yourself)","text":"<p>Repetition leads to inconsistencies and harder maintenance. Abstract common patterns and reuse code effectively.</p> <p>Bad Example:</p> <pre><code>def calculate_area(length, width):\n   return length * width\n\n# Duplicated logic for square\ndef calculate_square_area(side):\n   return side * side\n</code></pre> <p>Good Example:</p> <pre><code>def calculate_area(*dimensions):\n   return dimensions[0] * dimensions[1] if len(dimensions) &gt; 1 else dimensions[0] ** 2\n</code></pre>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#orthogonality","title":"Orthogonality","text":"<p>Ensure components are independent:    - Change in one module should not affect others.    - Independent modules enable parallel development, easier testing, and debugging.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#prototypes-and-feedback","title":"Prototypes and Feedback","text":"<p>Build quick prototypes to validate ideas and reduce risks. Prototyping helps clarify requirements and find flaws early.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#the-basic-tools","title":"The Basic Tools:","text":"<ul> <li> <p>Master Your Tools</p> <ul> <li>Developers should master their editors, debuggers, version control systems, and build tools. Efficient use of tools saves time and reduces frustration.</li> </ul> </li> <li> <p>Automation: Automate repetitive tasks</p> <ul> <li>Use scripts for deployments, testing, and build processes.</li> <li>Automation minimizes human errors and accelerates workflows.</li> </ul> </li> <li>Text Manipulation:<ul> <li>Learn text manipulation tools like grep, awk, sed, or regular expressions. These skills are invaluable for analyzing logs or data transformations.</li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#pragmatic-paranoia","title":"Pragmatic Paranoia","text":"<ol> <li>Design by Contract         - Specify preconditions, postconditions, and invariants for functions and modules.         - Define explicit expectations to avoid hidden bugs.</li> <li> <p>Dead Programs Tell No Lies         - Fail fast! If a program detects an issue, terminate with a clear error message instead of trying to proceed.</p> </li> <li> <p>Assertive Programming</p> <ul> <li>Use assertions to validate assumptions and catch bugs early during development.</li> </ul> </li> <li> <p>Backup and Recovery</p> <ul> <li>Always anticipate failures:     Test disaster recovery procedures.     Automate backups and ensure they\u2019re recoverable.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#bend-or-break","title":"Bend, or Break","text":"<ol> <li>Flexible Code: Write adaptable code that can evolve:</li> <li>Use abstractions like interfaces and polymorphism. Avoid hardcoding assumptions.</li> <li>Decoupling: Minimize dependencies between components: Decoupled systems are easier to test, modify, and scale. Use dependency injection and clear interfaces.</li> <li> <p>Refactoring:    Refactor code frequently to improve its structure without altering functionality:</p> <ul> <li>Remove redundancy.</li> <li>Simplify complex logic.</li> <li>Improve readability.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#while-you-are-coding","title":"While You Are Coding","text":"<ol> <li>Say What You Mean Use expressive and meaningful names for variables, functions, and classes. Your code should be self-documenting.</li> </ol> <p>Bad Example:</p> <pre><code>def m(a, b):\n   return a * b\n</code></pre> <p>Good Example:</p> <pre><code>def calculate_area(length, width):\n   return length * width\n</code></pre> <ol> <li> <p>Avoid Programming by Coincidence    Don\u2019t rely on assumptions or accidental behaviors in your code. Write code that explicitly achieves the desired results.</p> </li> <li> <p>Refuse the Temptation to Guess    When debugging, don\u2019t make random guesses about the problem. Instead:</p> <ul> <li>Gather evidence.</li> <li>Use logging and debugging tools to pinpoint issues.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#before-the-project","title":"Before the Project","text":"<ol> <li>Requirements Matter<ul> <li>Clarify requirements early and avoid assumptions. Ask questions like:<ul> <li>Who are the stakeholders?</li> <li>What are the business goals?</li> <li>What constraints exist?</li> </ul> </li> </ul> </li> <li> <p>Validate Assumptions</p> <ul> <li>Prove assumptions with prototypes or small experiments. Don\u2019t build an entire system on shaky foundations.</li> </ul> </li> <li> <p>Pragmatic Estimation</p> <ul> <li>Estimate projects realistically:<ul> <li>Break down tasks into smaller units.</li> <li>Factor in uncertainties.</li> <li>Communicate assumptions to stakeholders.</li> </ul> </li> </ul> </li> <li>Pragmatic Projects<ol> <li>Pragmatic Teams</li> <li>Effective teamwork involves: <ul> <li>Clear communication: Use simple language to avoid misunderstandings.</li> <li>Collective code ownership: Everyone contributes to and understands the codebase.</li> <li>Continuous learning: Share knowledge and mentor others.</li> </ul> </li> <li>Continuous Integration<ul> <li>Integrate code changes frequently and automate testing to catch issues early. Continuous integration ensures the codebase is always in a deployable state.</li> </ul> </li> <li>Pragmatic Starter Kit<ul> <li>Essential practices for every project:</li> <li>Version control: Track every change.</li> <li>Issue tracking: Log and prioritize tasks and bugs.</li> <li>Testing: Write automated unit, integration, and end-to-end tests.</li> </ul> </li> </ol> </li> <li>Pragmatic Programming Techniques<ul> <li>Tracer Bullets: Implement end-to-end functionality early to guide development and test architecture.</li> <li>Spikes: Write short, disposable code to explore and solve specific problems.</li> <li>Domain Languages: Create domain-specific languages to simplify communication and development.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#top-takeaways-from-the-pragmatic-programmer","title":"Top Takeaways from The Pragmatic Programmer","text":"<p>Invest in Your Knowledge Portfolio Continuously learn new technologies, languages, and practices. Stay curious and adaptable.</p> <p>Communicate Clearly Be precise with requirements and documentation. Avoid ambiguity to reduce misunderstandings.</p> <p>Iterative Development Break projects into small, manageable pieces. Ship features incrementally and iterate based on feedback.</p> <p>Be a Pragmatic Problem-Solver Embrace practical solutions over theoretical perfection. Balance trade-offs to meet deadlines while maintaining quality.</p> <p>Take Responsibility Own your decisions, from code quality to project outcomes. Always strive to deliver value.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#conclusion","title":"Conclusion","text":"<p>\"The Pragmatic Programmer\" is more than a programming book; it\u2019s a guide to becoming a better software professional. The lessons focus on practical, real-world strategies for solving problems, working in teams, and building robust software systems. Its timeless principles are as relevant today as when the book was first published.</p> <p>By adopting the pragmatic programmer mindset, developers can create high-quality software, collaborate effectively, and continuously grow in their careers.</p>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/","title":"System Design Interview","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#overview","title":"Overview","text":"<p>System Design Interview \u2013 An Insider\u2019s Guide by Alex Xu is structured as a practical guide to help software engineers prepare for system design interviews. It demystifies complex concepts through real-world examples, explaining how to approach designing large-scale distributed systems systematically. The book emphasizes trade-offs, scalability, reliability, and maintainability.</p>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#core-themes-and-concepts","title":"Core Themes and Concepts","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#1-system-design-fundamentals","title":"1. System Design Fundamentals","text":"<p>The book begins by introducing fundamental principles that form the backbone of any system design:</p> <ul> <li> <p>Scalability: Building systems to handle increasing loads.</p> </li> <li> <p>Reliability: Ensuring system availability even under failure conditions.</p> </li> <li> <p>Maintainability: Designing systems for ease of updates and debugging.</p> </li> <li> <p>Performance: Optimizing latency and throughput.</p> </li> <li> <p>Cost-effectiveness: Balancing design choices against infrastructure costs.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#2-structured-approach-to-system-design","title":"2. Structured Approach to System Design","text":"<p>A key strength of the book is its systematic framework for tackling system design problems:</p> <ol> <li> <p>Understand the requirements: Carefully clarify functional and non-functional requirements.</p> <ul> <li> <p>Functional: Features the system must support.</p> </li> <li> <p>Non-functional: Constraints like latency, throughput, consistency, and reliability.</p> </li> </ul> </li> <li> <p>Establish the scale: Estimate the expected load, such as queries per second (QPS), storage, or traffic.</p> </li> <li> <p>Define high-level architecture: Break the system into major components, such as APIs, databases, and caching layers.</p> </li> <li> <p>Design core components: Dive deeper into the design of key elements.</p> </li> <li> <p>Address bottlenecks: Identify and solve scalability and reliability challenges.</p> </li> </ol> <p>This structure ensures a logical flow while solving open-ended system design problems.</p>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#design-patterns-and-concepts","title":"Design Patterns and Concepts","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#1-load-balancing","title":"1. Load Balancing","text":"<ul> <li> <p>Load balancers distribute incoming traffic to multiple servers to ensure even workload distribution.</p> </li> <li> <p>Key techniques:</p> <ul> <li> <p>DNS load balancing: Simple but lacks dynamic adjustment.</p> </li> <li> <p>Reverse proxies: Flexible and common in modern architectures.</p> </li> <li> <p>Health checks: Ensure failed servers are removed from the load balancer\u2019s pool.</p> </li> </ul> </li> <li> <p>Example: Designing a system for millions of concurrent users often requires multiple layers of load balancing.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#2-database-design","title":"2. Database Design","text":"<ul> <li> <p>Relational vs. NoSQL: Use relational databases for ACID compliance and NoSQL for horizontal scalability.</p> </li> <li> <p>Sharding: Splitting data across multiple databases to handle high-scale workloads.</p> <ul> <li>Techniques: Range-based, hash-based, or geo-based sharding.</li> </ul> </li> <li> <p>Replication: Ensures high availability by duplicating data across servers.</p> <ul> <li> <p>Master-slave replication: Reads are served by replicas; writes go to the master.</p> </li> <li> <p>Leaderless replication: Used in systems like DynamoDB for availability.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#3-caching","title":"3. Caching","text":"<ul> <li> <p>Caching is a vital performance optimization strategy.</p> </li> <li> <p>Types:</p> <ul> <li> <p>Client-side caching: Stored on users' devices.</p> </li> <li> <p>Server-side caching: Common solutions like Memcached or Redis.</p> </li> </ul> </li> <li> <p>Cache invalidation: Critical for maintaining consistency between the cache and the database.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#4-messaging-systems","title":"4. Messaging Systems","text":"<ul> <li> <p>Messaging systems, like Kafka or RabbitMQ, decouple components and handle asynchronous communication.</p> </li> <li> <p>Common use cases:</p> <ul> <li> <p>Data pipelines for analytics.</p> </li> <li> <p>Event-driven architectures.</p> </li> <li> <p>Buffering high-throughput write requests to the database.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#5-content-delivery-networks-cdns","title":"5. Content Delivery Networks (CDNs)","text":"<ul> <li> <p>CDNs cache static content geographically closer to users to reduce latency and bandwidth usage.</p> </li> <li> <p>Often used in systems like video streaming platforms or image-heavy websites.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#case-studies","title":"Case Studies","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#1-designing-a-url-shortener","title":"1. Designing a URL Shortener","text":"<ul> <li> <p>Requirements:</p> <ul> <li> <p>Generate short URLs.</p> </li> <li> <p>Support redirection from short URLs to original ones.</p> </li> <li> <p>Handle 100M new URLs/day and 1000 requests/second.</p> </li> </ul> </li> <li> <p>Design:</p> <ul> <li> <p>Use a hash function to generate short URLs.</p> </li> <li> <p>Store mappings in a database (e.g., NoSQL for scalability).</p> </li> <li> <p>Introduce caching to speed up redirection.</p> </li> <li> <p>Handle collisions in hash-based generation.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#2-designing-a-tinyurl-with-scalability","title":"2. Designing a TinyURL with Scalability","text":"<ul> <li> <p>Additional considerations include:</p> <ul> <li> <p>Database partitioning (sharding by hash prefix).</p> </li> <li> <p>Distributed ID generation (e.g., Snowflake algorithm) to ensure uniqueness across multiple servers.</p> </li> <li> <p>CDN for serving static resources.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#3-designing-a-social-media-news-feed","title":"3. Designing a Social Media News Feed","text":"<ul> <li> <p>Requirements:</p> <ul> <li> <p>Personalized feed for each user.</p> </li> <li> <p>High throughput for millions of users.</p> </li> </ul> </li> <li> <p>Design:</p> <ul> <li> <p>Push-based model: Pre-compute feeds for each user as posts are created.</p> </li> <li> <p>Pull-based model: Generate feeds on demand.</p> </li> <li> <p>Optimize storage with denormalization and use distributed caching for fast retrieval.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#4-designing-a-messaging-system","title":"4. Designing a Messaging System","text":"<ul> <li> <p>Requirements:</p> <ul> <li> <p>One-to-one and group messaging.</p> </li> <li> <p>Deliver messages in real-time.</p> </li> </ul> </li> <li> <p>Design:</p> <ul> <li> <p>Use a publish-subscribe model for real-time delivery.</p> </li> <li> <p>Ensure durability by persisting messages to disk.</p> </li> <li> <p>Handle offline users by queuing messages.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#advanced-topics","title":"Advanced Topics","text":"<p>The book goes beyond basic designs to address more complex challenges:</p> <ul> <li> <p>Consistency vs. Availability (CAP Theorem):</p> <ul> <li> <p>Understand trade-offs in distributed systems.</p> </li> <li> <p>Use eventual consistency models for systems prioritizing availability.</p> </li> </ul> </li> <li> <p>Database indexing: Improves read performance but adds write overhead.</p> </li> <li> <p>Rate limiting: Throttle requests to prevent abuse and protect backends.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Trade-offs are central: Every design decision involves a trade-off (e.g., latency vs. consistency, cost vs. scalability).</p> </li> <li> <p>High-level thinking matters: Interviews often test how well you can reason about complex systems, not just low-level implementation details.</p> </li> <li> <p>Practice is essential: Work through real-world scenarios to build confidence and intuition.</p> </li> </ol>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#why-this-book-is-valuable","title":"Why This Book is Valuable","text":"<ul> <li> <p>Clarity: Concepts are explained in simple language with visual diagrams.</p> </li> <li> <p>Practical Examples: Real-world cases like URL shorteners and newsfeeds offer hands-on learning.</p> </li> <li> <p>Interview-focused: Aimed at helping candidates succeed in system design interviews.</p> </li> </ul>"}]}