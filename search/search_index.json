{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Learn with Shashank","text":"<p>Welcome to Learn with Shashank \u2014 a space where I document my journey of continuous learning and share insights on various topics related to software development and beyond.</p> <p>This is not just a personal archive but an open resource available for anyone eager to learn and explore new concepts. Whether you're a fellow developer, a tech enthusiast, or someone curious about the ever-evolving world of software, you'll find something here that piques your interest!</p>"},{"location":"#about-me","title":"About Me","text":"<p>Hi there! I'm Shashank, a passionate software developer who loves to tinker with code and explore the latest trends in technology. When I'm not building or programming, you'll find me diving into new ideas, tools, and methodologies \u2014 always with a curious mindset.</p> <p>I believe in continuous learning and try to stay up-to-date with the latest in programming, software engineering, and development practices. Whether it's exploring a new framework, learning best coding practices, or understanding architectural patterns, I'm constantly experimenting and improving my craft.</p>"},{"location":"#what-youll-find-here","title":"What You'll Find Here","text":"<p>On this website, I document my journey of learning, coding, and software engineering. You\u2019ll find content that covers:</p> <ul> <li>Developer Learning: Insights into programming languages, frameworks, tools, and best practices.</li> <li>Generic Software Engineering: Broader topics such as system design, architecture, software development methodologies, and more.</li> <li>Miscellaneous: A collection of random thoughts, ideas, and anything else that sparks curiosity!</li> </ul>"},{"location":"#join-the-journey","title":"Join the Journey","text":"<p>I\u2019m excited to share what I learn along the way and invite you to join me. Whether you\u2019re just starting out in the tech world or are a seasoned developer, I hope you\u2019ll find something here to inspire you.</p> <p>Feel free to explore, learn, and contribute your thoughts. Let's grow together in this ever-evolving world of technology!</p>"},{"location":"data_structures_and_algorithms/","title":"DataStructures and Algorithms","text":"<p>This section covers data structures and algorithms problems and their explanation</p>"},{"location":"data_structures_and_algorithms/#dsa","title":"DSA","text":"<ul> <li>Arrays/Strings</li> <li>Two Pointers</li> <li>Sliding Window</li> <li>Matrix</li> <li>Hashmap</li> <li>Intervals</li> <li>Stack</li> <li>Linked List</li> <li>Binary Tree General</li> <li>Binary Tree BFS</li> <li>Binary Search Tree</li> <li>Graph General</li> <li>Graph BFS</li> <li>Trie</li> <li>Backtracking</li> <li>Divide &amp; Conquer</li> <li>Kadane's Algorithm</li> <li>Binary Search</li> <li>Heap</li> <li>Bit Manipulation</li> <li>Math</li> <li>1D DP</li> <li>Multidimensional DP</li> </ul>"},{"location":"developer_learning/","title":"Developer Learnings","text":"<p>This section will feature interesting blog posts and concise concepts on key software engineering practices and methodologies. I will share valuable insights from foundational books and various topics that every developer should explore and learn from.</p>"},{"location":"developer_learning/#blogs-from-me","title":"Blogs from me","text":"<ul> <li>Designing Scalable Notification Service</li> <li>Bare-Metal vs Cloud: A Smarter Choice for Scaling Infrastructure</li> </ul>"},{"location":"developer_learning/#interesting-blogs","title":"Interesting Blogs","text":"<ul> <li>How to Run a Docker Container on AWS EC2 and Access It Externally</li> </ul>"},{"location":"generic_software_engineering/","title":"Generic Software Engineering","text":"<p>This section covers key concepts and best practices in software engineering. Here, you\u2019ll find detailed notes and insights on foundational books and methodologies that every developer should be familiar with.</p>"},{"location":"generic_software_engineering/#book-summary","title":"Book Summary","text":"<ul> <li>Clean code: Best practices for writing readable, maintainable, and efficient code.</li> <li>Pragmatic Programmer: Essential advice and principles for becoming a more effective and adaptable developer.</li> <li>System Design Interview:  Best practices for designing scalable, reliable, and maintainable systems.</li> </ul>"},{"location":"miscellaneous/","title":"Miscellaneous","text":""},{"location":"DataStructuresAndAlgorithms/Arrays/","title":"Arrays and strings","text":"<p>LeetCode 88: Merge Sorted Array step by step.</p> <p>\ud83e\udde0 Problem Understanding: You're given: Two sorted arrays nums1 and nums2. nums1 has extra space at the end to hold all elements from nums2. The actual number of meaningful elements in nums1 is m. The number of elements in nums2 is n.</p> <p>Your task is to merge nums2 into nums1 in-place, so that nums1 becomes a fully sorted array.</p> <p>\ud83d\udd0d Key Insight: Since nums1 has extra space at the end, we can fill from the back instead of the front. That way, we don\u2019t overwrite any elements we haven\u2019t checked yet.</p> <p>\u2705 Strategy: Use three pointers: p1 = m - 1: points to the last element in the actual nums1 values. p2 = n - 1: points to the last element in nums2. p = m + n - 1: points to the last position in nums1.</p> <p>Compare elements from the back of nums1 and nums2, and place the larger one at position p. Decrease p and whichever pointer (p1 or p2) you just used. At the end, if any elements are left in nums2, copy them (this only happens if they are all smaller than nums1's smallest).</p> <p>\ud83e\uddd1\u200d\ud83d\udcbb Code (Python):</p> <pre><code>\ndef merge(nums1, m, nums2, n):\n    p1 = m - 1  # last element of nums1 (non-zero part)\n    p2 = n - 1  # last element of nums2\n    p = m + n - 1  # last position in nums1\n\n    # Compare from the end\n    while p1 &gt;= 0 and p2 &gt;= 0:\n        if nums1[p1] &gt; nums2[p2]:\n            nums1[p] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[p] = nums2[p2]\n            p2 -= 1\n        p -= 1\n\n    # If any elements are left in nums2\n    while p2 &gt;= 0:\n        nums1[p] = nums2[p2]\n        p2 -= 1\n        p -= 1\n</code></pre> <p>LeetCode 27: Remove Element.</p> <p>\ud83e\udde0 Problem Understanding You are given:</p> <p>An integer array nums An integer val</p> <p>Your task: Remove all instances of val from the array nums, in-place Return the count of elements that are not equal to val</p> <p>\ud83d\udd38 Constraints:</p> <p>You don\u2019t need to maintain the order of elements Do it in-place (no extra space)</p> <p>\u2705 What You Need to Do: Modify nums in-place such that: The first k elements are the ones not equal to val Return k, the number of elements not equal to val \u26a0\ufe0f The contents beyond the first k elements don't matter.</p> <p>\ud83d\udd0d Strategy (Two Pointer Approach): Use a write pointer (i) that keeps track of where to write the next non-val element.</p> <p>Steps: Initialize i = 0 Loop through each element num in nums If num != val: Write num at index i \u2192 nums[i] = num Increment i At the end: First i elements of nums are the result Return i</p> <p>\ud83e\uddd1\u200d\ud83d\udcbb Python Code:</p> <pre><code>def removeElement(nums, val):\n    i = 0  # write pointer\n\n    for num in nums:\n        if num != val:\n            nums[i] = num\n            i += 1\n\n    return i\n</code></pre> <p>LeetCode 26: Remove Duplicates from Sorted Array.</p> <p>\ud83e\udde0 Problem Summary: Given: A sorted integer array nums (non-decreasing order).</p> <p>Your task: Remove duplicates in-place such that each unique element appears only once. Keep the relative order of the elements the same. Return the count k of unique elements. The first k elements in nums should be the unique values in order.</p> <p>\ud83d\udd0d Key Insight: Because the array is already sorted, all duplicates will be next to each other. We can use the two-pointer technique: One pointer (i) keeps track of the last unique element Another pointer (j) scans through the array</p> <p>\u2705 Strategy (Two Pointers): If the array is empty, return 0. Start with i = 0 (position to write next unique value). Loop j from 1 to end of the array: If nums[j] != nums[i], it means a new unique element is found. Move i one step ahead Copy nums[j] to nums[i] At the end, return i + 1 (count of unique elements)</p> <pre><code>\ndef removeDuplicates(nums):\n    if not nums:\n        return 0\n\n    i = 0  # pointer to last unique element\n\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]  # place unique element at the correct spot\n\n    return i + 1\n</code></pre> <p>Remove Duplicates from Sorted Array\" problem \u2014 this is sometimes referred to as \u201cRemove Duplicates II\u201d on LeetCode.</p> <p>\ud83e\udde0 Problem Summary: Given:</p> <p>A sorted array nums (non-decreasing order). Your task: Modify the array in-place so that each unique element appears at most twice. Keep the relative order the same. Return k, the number of valid elements in the modified array (first k elements).</p> <p>\ud83d\udd0d Key Idea: Since the array is sorted: All duplicates are grouped together. You are allowed up to 2 of each element. We\u2019ll use the two-pointer technique again: Pointer i is the write pointer (where to write the next valid element). Pointer j scans through the array.</p> <p>\u2705 Strategy (Two Pointers with a Rule): Initialize i = 0 (start writing from the beginning). Loop through the array with j: If i &lt; 2, always write nums[j] (first two elements are always allowed). If nums[j] != nums[i - 2], then write nums[j] at nums[i]. Why i - 2? Because we\u2019re allowing at most 2 of the same number.</p> <p>\ud83e\uddd1\u200d\ud83d\udcbb Python Code:</p> <pre><code>def removeDuplicates(nums):\n    i = 0  # write pointer\n\n    for num in nums:\n        if i &lt; 2 or num != nums[i - 2]:\n            nums[i] = num\n            i += 1\n\n    return i\n</code></pre> <p>Given an integer array nums, return the majority element \u2014 the element that appears more than n//2 times. You are guaranteed that a solution always exists.</p> <p>\ud83e\udde0 Your Code: python</p> <pre><code>class Solution:\n    def majorityElement(self, nums: List[int]) -&gt; int:\n        counts = {}\n        max_count = len(nums)//2\n\n        for num in nums:\n            if num in counts:\n                counts[num] += 1\n            else:\n                counts[num] = 1\n\n            if counts[num] &gt; max_count:\n                return num\n</code></pre> <p>\ud83d\udd0d Explanation: Step 1: Initialize dictionary and threshold python Copy Edit counts = {} max_count = len(nums) // 2 counts is a dictionary to store the frequency of each number.</p> <p>max_count is the majority threshold. A number must appear more than this to be considered the majority element.</p> <p>Step 2: Loop through each number python Copy Edit for num in nums: Iterate through each element in the nums array.</p> <p>Step 3: Count frequency of each number python Copy Edit if num in counts:     counts[num] += 1 else:     counts[num] = 1 If the number already exists in the dictionary, increment its count.</p> <p>Otherwise, initialize its count to 1.</p> <p>Step 4: Check if it's the majority python if counts[num] &gt; max_count:     return num After updating the count, check if it crossed the majority threshold.</p> <p>If yes, return it immediately (early exit \u2014 very efficient).</p> <p>Leetcode 189. Rotate Array step-by-step so you fully understand it. \u2705 Optimal Approach (O(n) Time, O(1) Space): We can solve this in 3 simple steps using array reversals:</p> <p>\ud83d\udd01 Key Idea: To rotate right by k:</p> <p>Reverse the whole array</p> <p>Reverse the first k elements</p> <p>Reverse the remaining (n-k) elements</p> <p>\ud83d\udc47 Example Walkthrough: python Copy Edit nums = [1,2,3,4,5,6,7] k = 3</p> <p>Step 1: Reverse all \u2192 [7,6,5,4,3,2,1]  Step 2: Reverse first 3 \u2192 [5,6,7,4,3,2,1]  Step 3: Reverse rest \u2192 [5,6,7,1,2,3,4] Done!</p> <p>\u2705 Python Code: python</p> <pre><code>class Solution:\n    def rotate(self, nums: List[int], k: int) -&gt; None:\n        n = len(nums)\n        k %= n  # handle k &gt; n\n\n        def reverse(start, end):\n            while start &lt; end:\n                nums[start], nums[end] = nums[end], nums[start]\n                start += 1\n                end -= 1\n\n        # Step 1: Reverse the whole array\n        reverse(0, n - 1)\n\n        # Step 2: Reverse first k elements\n        reverse(0, k - 1)\n\n        # Step 3: Reverse remaining n-k elements\n        reverse(k, n - 1)\n</code></pre> <p>\u2705 Time &amp; Space Complexity: Time: O(n)</p> <p>Space: O(1) (in-place)</p> <p>Leetcode 121: Best Time to Buy and Sell Stoc \u2705 Optimal Solution (O(n) Time, O(1) Space): \ud83c\udfaf Key Idea: Track the lowest price so far (best day to buy).</p> <p>At each day, calculate the potential profit if we sold on that day. Keep updating the maximum profit.</p> <p>\ud83d\udc47 Step-by-Step Walkthrough: python</p> <p>prices = [7,1,5,3,6,4]</p> <p>min_price = \u221e max_profit = 0</p> <p>Day 0: price = 7 \u2192 min_price = 7 Day 1: price = 1 \u2192 min_price = 1 Day 2: price = 5 \u2192 profit = 5 - 1 = 4 \u2192 max_profit = 4 Day 3: price = 3 \u2192 profit = 3 - 1 = 2 \u2192 max_profit = 4 Day 4: price = 6 \u2192 profit = 6 - 1 = 5 \u2192 max_profit = 5 \u2705 Day 5: price = 4 \u2192 profit = 4 - 1 = 3 \u2192 max_profit = 5</p> <p>\u2705 Python Code: python</p> <pre><code>class Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        min_price = float('inf')  # Start with a very high price\n        max_profit = 0\n\n        for price in prices:\n            if price &lt; min_price:\n                min_price = price  # Update the lowest price so far\n            elif price - min_price &gt; max_profit:\n                max_profit = price - min_price  # Update max profit if better\n\n        return max_profit\n</code></pre> <p>\u2705 Time &amp; Space Complexity: Time: O(n) \u2192 We loop through the prices only once.</p> <p>Space: O(1) \u2192 No extra space used.</p> <p>Leetcode 122. Best Time to Buy and Sell Stock II</p> <p>\ud83e\udde0 Problem Summary You are given a list of stock prices, where prices[i] is the price on day i. You can buy and sell as many times as you want (even on the same day), but you must sell before you buy again (you can't hold more than one share at a time).</p> <p>Goal: Maximize your profit.</p> <p>\u2705 Key Insight This problem is about taking every opportunity to make profit, no matter how small. \ud83d\udc49 If the price tomorrow is higher than today, then buy today and sell tomorrow. For example:</p> <p>plaintext</p> <p>prices = [7,1,5,3,6,4]           \u2191 \u2193 \u2191 \u2193 \u2191 \u2193 Opportunities to make profit:</p> <p>Buy at 1, sell at 5 \u2192 profit = 4 Buy at 3, sell at 6 \u2192 profit = 3 Total profit = 4 + 3 = 7</p> <p>\ud83d\udca1 Greedy Approach (Simple) python</p> <pre><code>class Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        profit = 0\n\n        for i in range(1, len(prices)):\n            if prices[i] &gt; prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n\n        return profit\n</code></pre> <p>\ud83e\uddea Explanation We loop from day 1 to end.</p> <p>If today\u2019s price (prices[i]) is greater than yesterday\u2019s price (prices[i - 1]), it means we could\u2019ve bought yesterday and sold today. So, we add the profit: prices[i] - prices[i - 1]. This effectively adds up all positive profit differences \u2014 which is exactly what we want.</p> <p>\u23f1\ufe0f Time and Space Complexity Time: O(n) \u2014 One pass through the list.</p> <p>Space: O(1) \u2014 Constant space used.</p> <p>LeetCode 55 \u2013 Jump Game. Greedy Observation While scanning from left to right, it is enough to know the furthest position we can reach so far.</p> <p>Why? Suppose we are at index i. If the current furthest reachable index (far) is \u2265 i, we have already proven we can stand on i. From i, the best we can do is extend far to max(far, i + nums[i]).</p> <p>If at any time far &lt; i, we hit a \u201cgap\u201d we cannot cross \u2192 return false immediately.</p> <p>If we finish the scan with far \u2265 last_index, then we can reach the end \u2192 true.</p> <p>This one-pass greedy works because earlier indices can only jump forward; once we\u2019ve computed the global maximum reach up to position i, no later step can improve reachability of any earlier gap we already failed.</p> <p>4 Algorithm in Plain English python</p> <pre><code>far = 0                                # furthest index we can reach so far\nfor i from 0 to n-1:\n    if i &gt; far:                       # gap!\n        return False\n    far = max(far, i + nums[i])       # extend reach\nreturn True                            # far never dropped behind i\n</code></pre> <p>Python Implementation python</p> <pre><code>class Solution:\n    def canJump(self, nums: list[int]) -&gt; bool:\n        far = 0\n        for i, step in enumerate(nums):\n            if i &gt; far:                       # cannot even stand on i\n                return False\n            far = max(far, i + step)          # best we can do from here\n            if far &gt;= len(nums) - 1:          # early exit: already at/over end\n                return True\n        return True\n</code></pre> <p>Complexity Value Time    O(n) \u2013 one linear scan Space   O(1) \u2013 just the integer far</p> <p>LeetCode 45 \u2013 Jump Game II in a way that makes it super intuitive to understand and solve.</p> <p>\ud83e\udde0 Problem Understanding Given:</p> <p>An array nums, where nums[i] is the maximum jump length you can take from index i.</p> <p>Goal:</p> <p>Reach the last index (nums[n - 1]) using the minimum number of jumps.</p> <p>Constraints:</p> <p>You can reach the end (i.e., it's guaranteed).</p> <p>From nums[i], you can jump to any nums[i + j] where 0 &lt; j \u2264 nums[i].</p> <p>\ud83c\udfc3 Real-World Analogy Think of it like this:</p> <p>You're standing on stones in a river, and each stone tells you how many stones forward you can jump. Your goal is to cross the river in as few jumps as possible.</p> <p>\u2705 Example nums = [2, 3, 1, 1, 4] Start at index 0:</p> <p>You can jump to index 1 or index 2 (nums[0] = 2)</p> <p>What's the best place to jump to?</p> <p>Pick the one that gives you the furthest reach in the next move (greedy choice).</p> <p>From index 1 (which has value 3), you can go to indices 2, 3, or 4.</p> <p>So jump from 0 \u2192 1, then 1 \u2192 4.</p> <p>Total jumps = 2</p> <p>\ud83d\udca1 Intuition We use a greedy level-based BFS approach. Each \u201cjump\u201d is like one level of BFS traversal.</p> <p>Track: currentEnd: the end of the current jump range.</p> <p>farthest: the farthest index we can reach in the next jump.</p> <p>Every time we reach currentEnd, we:</p> <p>Increment jumps</p> <p>Update currentEnd = farthest</p> <p>\u2705 Greedy Algorithm</p> <pre><code>class Solution:\n    def jump(self, nums: list[int]) -&gt; int:\n        jumps = 0\n        currentEnd = 0\n        farthest = 0\n\n        for i in range(len(nums) - 1):  # no need to jump from last index\n            farthest = max(farthest, i + nums[i])\n            if i == currentEnd:\n                jumps += 1\n                currentEnd = farthest\n\n        return jumps\n\n</code></pre> <p>H-Index problem in a very simple and clear way.</p> <p>\ud83d\udd0d What is H-Index? The H-Index is a number that measures both: Productivity (number of papers), and Impact (number of citations).</p> <p>\ud83e\udde0 Definition: A researcher has an index h if h of their n papers have at least h citations each, and the rest of the papers have no more than h citations.</p> <p>\u2705 Let's break the example down: Input: citations = [3, 0, 6, 1, 5]</p> <p>This means: Paper 1 has 3 citations Paper 2 has 0 Paper 3 has 6 Paper 4 has 1 Paper 5 has 5</p> <p>Now, we want to find the largest number h such that at least h papers have \u2265 h citations.</p> <p>\ud83d\ude80 Step-by-step Dry Run Sort the citations in descending order:</p> <p>[6, 5, 3, 1, 0] Now go one by one and check:</p> <p>At index 0: 6 citations \u2192 at least 1 paper has \u2265 1 citation \u2705</p> <p>At index 1: 5 citations \u2192 at least 2 papers have \u2265 2 citations \u2705</p> <p>At index 2: 3 citations \u2192 at least 3 papers have \u2265 3 citations \u2705</p> <p>At index 3: 1 citation \u2192 at least 4 papers have \u2265 4 citations \u274c (only 3 papers do)</p> <p>\u2705 So the highest h that satisfies the condition is 3.</p> <p>\u2705 Final Code (Python)</p> <pre><code>class Solution:\n    def hIndex(self, citations: List[int]) -&gt; int:\n        citations.sort(reverse=True)\n        h = 0\n        for i, c in enumerate(citations):\n            if c &gt;= i + 1:\n                h += 1\n            else:\n                break\n        return h\n</code></pre>"},{"location":"DataStructuresAndAlgorithms/bfs/","title":"BFS","text":""},{"location":"DataStructuresAndAlgorithms/binary_tree_general/","title":"Binary tree","text":""},{"location":"DataStructuresAndAlgorithms/bst/","title":"bst","text":""},{"location":"DataStructuresAndAlgorithms/graphs/","title":"graphs","text":""},{"location":"DataStructuresAndAlgorithms/hashmap/","title":"HashMap","text":""},{"location":"DataStructuresAndAlgorithms/intervals/","title":"Intervals","text":""},{"location":"DataStructuresAndAlgorithms/linked_list/","title":"LinkedLists","text":""},{"location":"DataStructuresAndAlgorithms/matrix/","title":"Matrix","text":""},{"location":"DataStructuresAndAlgorithms/sliding_window/","title":"Sliding window","text":""},{"location":"DataStructuresAndAlgorithms/stack/","title":"stacks","text":""},{"location":"DataStructuresAndAlgorithms/two_pointers/","title":"Two pointers","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/","title":"Clean Code","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/#introduction","title":"Introduction","text":"<p>\"Clean Code\" is a seminal book in software engineering that emphasizes the importance of writing code that is not only functional but also maintainable, readable, and efficient. Robert C. Martin, also known as \"Uncle Bob,\" provides principles, practices, and case studies to teach developers how to write \"clean\" code. The book is divided into three parts:</p> <ol> <li>Principles, patterns, and best practices.</li> <li>Case studies for cleaning up code.</li> <li>A list of heuristics for writing clean code.</li> </ol>"},{"location":"GeneralSoftwareEngineering/CleanCode/#what-is-clean-code","title":"What is Clean Code?","text":"<p>Clean code is described as simple, direct, and elegant. Martin highlights that clean code:</p> <ul> <li>Reads like prose: It should be understandable without additional explanations.</li> <li>Focuses on one task: Each component should do one thing well.</li> <li>Avoids redundancy: Repeated patterns or logic should be eliminated.</li> <li>Is testable and reliable: Bugs should be easy to spot an</li> </ul> <p>He compares clean code to well-written essays\u2014structured, concise, and free from unnecessary details.</p>"},{"location":"GeneralSoftwareEngineering/CleanCode/#key-principles-of-clean-code","title":"Key Principles of Clean Code","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/#meaningful-names","title":"Meaningful Names","text":"<ul> <li>Purposeful: Variable, function, and class names should reflect their purpose and behavior.</li> <li>Avoid abbreviations: Full words are better for readability.</li> <li>Pronounceable names: Make code easier to discuss with teammates.</li> <li>Consistency: Use consistent naming conventions across the codebase.</li> </ul> <p>Bad Example:</p> <pre><code>int d; // What does 'd' represent?\n</code></pre> <p>Good Example:</p> <pre><code>int daysSinceLastUpdate;\n\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#functions","title":"Functions","text":"<ul> <li> <p>Functions are the building blocks of any codebase. To write clean functions:</p> </li> <li> <p>Keep them small: Functions should ideally be 20 lines or less.</p> </li> <li>Single Responsibility: Each function should do one thing and do it well.</li> <li>Avoid side effects: Functions should not alter global states.</li> <li>Descriptive names: Function names should clearly state their purpose.</li> </ul> <p>Bad Example:</p> <pre><code>void process(int a, int b); // Vague purpose\n</code></pre> <p>Good Example:</p> <pre><code>void processOrder(int orderId, int customerId);\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#comments","title":"Comments","text":"<ul> <li>Martin discourages excessive commenting because comments can become outdated as code changes. Instead:</li> <li>Write self-explanatory code that doesn\u2019t need comments.</li> <li>Use comments sparingly for clarifications or highlighting important decisions.</li> <li>Avoid redundant or misleading comments. Bad Example:</li> </ul> <pre><code>// Increment i by 1\ni = i + 1;\n</code></pre> <p>Good Example:</p> <pre><code>// Use this method for backward compatibility with version 1.0\nupdateLegacyData();\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#error-handling","title":"Error Handling","text":"<ul> <li>Don\u2019t ignore exceptions: Handle errors where they occur.</li> <li>Use custom exceptions: Give specific context to errors.</li> <li>Fail fast: Detect and report errors early.</li> <li>Avoid returning null: It leads to null pointer exceptions. Use objects or default values instead.</li> </ul> <p>Bad Example:</p> <pre><code>if (user == null) {\n    // Ignore the issue\n}\n</code></pre> <p>Good Example:</p> <pre><code>if (user == null) {\n    throw new IllegalArgumentException(\"User cannot be null\");\n}\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#formatting","title":"Formatting:","text":"<p>Consistent formatting improves readability:</p> <ul> <li>Follow an agreed-upon style guide.</li> <li>Use proper indentation and spacing.</li> <li>Group related code together logically.</li> <li>Maintain vertical and horizontal alignment to prevent clutter.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#objects-and-data-structures","title":"Objects and Data Structures","text":"<ul> <li>Objects should hide implementation details and expose only essential methods:</li> <li>Encapsulation: Use private fields and public getters/setters.</li> <li>Avoid getters/setters overuse: Instead, expose meaningful behavior.</li> </ul> <p>Bad Example:</p> <pre><code>user.setFirstName(\"John\");\nuser.setLastName(\"Doe\");\n</code></pre> <p>Good Example:</p> <pre><code>user.updateName(\"John Doe\");\n</code></pre>"},{"location":"GeneralSoftwareEngineering/CleanCode/#unit-testing","title":"Unit Testing","text":"<ul> <li>Testing is a cornerstone of clean code. Good tests:</li> <li>Follow the FIRST principles (Fast, Independent, Repeatable, Self-Validating, and Timely).</li> <li>Cover edge cases and boundary conditions.</li> <li>Help detect bugs early and enforce code reliability.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#classes","title":"Classes","text":"<ul> <li>Keep classes small and focused: Each class should represent a single responsibility.</li> <li>Avoid God Classes: Classes that try to do too much.</li> <li>Follow SOLID principles for maintainable design.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#case-studies-cleaning-code","title":"Case Studies: Cleaning Code","text":"<p>The book provides practical examples of messy code and walks through the process of cleaning it. These case studies emphasize: - Refactoring for simplicity. - Removing unnecessary code. - Breaking large functions into smaller, reusable ones. - Testing after each change to ensure nothing breaks.</p> <p>For example, in one case study, Martin takes a long, convoluted function and breaks it down into smaller helper functions. This process involves:</p> <ul> <li>Identifying chunks of code that perform distinct tasks.</li> <li>Creating descriptive helper functions for these tasks.</li> <li>Removing redundant comments and making variable names more meaningful.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#advanced-topics","title":"Advanced Topics","text":""},{"location":"GeneralSoftwareEngineering/CleanCode/#boundaries","title":"Boundaries","text":"<ul> <li> <p>Managing boundaries involves:</p> </li> <li> <p>Minimizing dependencies between components.</p> </li> <li>Using clear interfaces for communication.</li> <li>Avoiding tight coupling, which makes code harder to modify.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#concurrency","title":"Concurrency","text":"<ul> <li>Writing concurrent code is tricky. Martin advises:<ul> <li>Keep data sharing between threads minimal.</li> <li>Use synchronization mechanisms cautiously.</li> <li>Write tests to simulate multithreaded environments.</li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#refactoring","title":"Refactoring","text":"<ul> <li> <p>Refactoring is a disciplined approach to improving code without changing its behavior. Key strategies include:</p> <ul> <li>Consolidating duplicate logic.</li> <li>Extracting methods or classes.</li> <li>Renaming components for clarity.</li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#clean-code-practices","title":"Clean Code Practices","text":"<ol> <li> <p>The Boy Scout Rule:  Always leave the codebase cleaner than you found it. Even small improvements\u2014like renaming variables or breaking down functions\u2014make a big difference over time.</p> </li> <li> <p>Avoid Premature Optimization: Focus on clarity and correctness before optimizing code. Premature optimization often leads to complex, unreadable code.</p> </li> <li> <p>Code Reviews: Engage in peer reviews to ensure code quality and share knowledge within the team.</p> </li> <li> <p>Continuous Improvement: Treat clean code as a continuous journey, not a one-time effort. Regularly revisit and refine your code.</p> </li> </ol>"},{"location":"GeneralSoftwareEngineering/CleanCode/#the-clean-code-mindset","title":"The Clean Code Mindset","text":"<p>Martin stresses that clean code is as much about mindset as it is about practices:</p> <ul> <li>Strive for craftsmanship and take pride in your work.</li> <li>Advocate for simplicity and clarity, even under deadlines.</li> <li>Understand that writing clean code may take more effort initially, but it pays off in the long run through easier maintenance and fewer bugs.</li> </ul>"},{"location":"GeneralSoftwareEngineering/CleanCode/#conclusion","title":"Conclusion","text":"<p>\"Clean Code\" is not just a technical manual but also a philosophy. It encourages developers to think critically about how they write and structure their code. The principles in the book aim to make codebases easier to understand, debug, and extend\u2014qualities that are essential in agile and collaborative environments.</p> <p>By adopting the practices outlined in \"Clean Code,\" developers can create software that stands the test of time, benefiting their teams and the broader community.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/","title":"The Pragmatic Programmer","text":""},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#introduction","title":"Introduction","text":"<p>\"The Pragmatic Programmer\" is a foundational book for software developers, emphasizing the mindset and habits necessary for effective, long-term growth in the field. Hunt and Thomas provide actionable advice on coding, debugging, project management, and professional development. The book is structured into a series of short, insightful lessons, organized into 8 major chapters.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#a-pragmatic-philosophy","title":"A Pragmatic Philosophy","text":"<ul> <li> <p>The authors introduce the pragmatic programmer mindset:</p> </li> <li> <p>Be responsible: Own your decisions, code quality, and the impact on the project.</p> </li> <li>Continuously learn: Stay curious and adaptable.</li> <li>Think critically: Avoid assumptions and validate ideas with evidence.</li> </ul>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#key-concepts","title":"Key concepts:","text":"<ul> <li>The Broken Window Theory: Fix small issues (e.g., bad code, tech debt) early to prevent a cascading decline in quality.</li> <li>Be a catalyst for change: Suggest improvements and help your team embrace better practices.</li> </ul>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#a-pragmatic-approach","title":"A Pragmatic Approach","text":""},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#dry-dont-repeat-yourself","title":"DRY (Don\u2019t Repeat Yourself)","text":"<p>Repetition leads to inconsistencies and harder maintenance. Abstract common patterns and reuse code effectively.</p> <p>Bad Example:</p> <pre><code>def calculate_area(length, width):\n   return length * width\n\n# Duplicated logic for square\ndef calculate_square_area(side):\n   return side * side\n</code></pre> <p>Good Example:</p> <pre><code>def calculate_area(*dimensions):\n   return dimensions[0] * dimensions[1] if len(dimensions) &gt; 1 else dimensions[0] ** 2\n</code></pre>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#orthogonality","title":"Orthogonality","text":"<p>Ensure components are independent:    - Change in one module should not affect others.    - Independent modules enable parallel development, easier testing, and debugging.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#prototypes-and-feedback","title":"Prototypes and Feedback","text":"<p>Build quick prototypes to validate ideas and reduce risks. Prototyping helps clarify requirements and find flaws early.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#the-basic-tools","title":"The Basic Tools:","text":"<ul> <li> <p>Master Your Tools</p> <ul> <li>Developers should master their editors, debuggers, version control systems, and build tools. Efficient use of tools saves time and reduces frustration.</li> </ul> </li> <li> <p>Automation: Automate repetitive tasks</p> <ul> <li>Use scripts for deployments, testing, and build processes.</li> <li>Automation minimizes human errors and accelerates workflows.</li> </ul> </li> <li>Text Manipulation:<ul> <li>Learn text manipulation tools like grep, awk, sed, or regular expressions. These skills are invaluable for analyzing logs or data transformations.</li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#pragmatic-paranoia","title":"Pragmatic Paranoia","text":"<ol> <li>Design by Contract         - Specify preconditions, postconditions, and invariants for functions and modules.         - Define explicit expectations to avoid hidden bugs.</li> <li> <p>Dead Programs Tell No Lies         - Fail fast! If a program detects an issue, terminate with a clear error message instead of trying to proceed.</p> </li> <li> <p>Assertive Programming</p> <ul> <li>Use assertions to validate assumptions and catch bugs early during development.</li> </ul> </li> <li> <p>Backup and Recovery</p> <ul> <li>Always anticipate failures:     Test disaster recovery procedures.     Automate backups and ensure they\u2019re recoverable.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#bend-or-break","title":"Bend, or Break","text":"<ol> <li>Flexible Code: Write adaptable code that can evolve:</li> <li>Use abstractions like interfaces and polymorphism. Avoid hardcoding assumptions.</li> <li>Decoupling: Minimize dependencies between components: Decoupled systems are easier to test, modify, and scale. Use dependency injection and clear interfaces.</li> <li> <p>Refactoring:    Refactor code frequently to improve its structure without altering functionality:</p> <ul> <li>Remove redundancy.</li> <li>Simplify complex logic.</li> <li>Improve readability.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#while-you-are-coding","title":"While You Are Coding","text":"<ol> <li>Say What You Mean Use expressive and meaningful names for variables, functions, and classes. Your code should be self-documenting.</li> </ol> <p>Bad Example:</p> <pre><code>def m(a, b):\n   return a * b\n</code></pre> <p>Good Example:</p> <pre><code>def calculate_area(length, width):\n   return length * width\n</code></pre> <ol> <li> <p>Avoid Programming by Coincidence    Don\u2019t rely on assumptions or accidental behaviors in your code. Write code that explicitly achieves the desired results.</p> </li> <li> <p>Refuse the Temptation to Guess    When debugging, don\u2019t make random guesses about the problem. Instead:</p> <ul> <li>Gather evidence.</li> <li>Use logging and debugging tools to pinpoint issues.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#before-the-project","title":"Before the Project","text":"<ol> <li>Requirements Matter<ul> <li>Clarify requirements early and avoid assumptions. Ask questions like:<ul> <li>Who are the stakeholders?</li> <li>What are the business goals?</li> <li>What constraints exist?</li> </ul> </li> </ul> </li> <li> <p>Validate Assumptions</p> <ul> <li>Prove assumptions with prototypes or small experiments. Don\u2019t build an entire system on shaky foundations.</li> </ul> </li> <li> <p>Pragmatic Estimation</p> <ul> <li>Estimate projects realistically:<ul> <li>Break down tasks into smaller units.</li> <li>Factor in uncertainties.</li> <li>Communicate assumptions to stakeholders.</li> </ul> </li> </ul> </li> <li>Pragmatic Projects<ol> <li>Pragmatic Teams</li> <li>Effective teamwork involves: <ul> <li>Clear communication: Use simple language to avoid misunderstandings.</li> <li>Collective code ownership: Everyone contributes to and understands the codebase.</li> <li>Continuous learning: Share knowledge and mentor others.</li> </ul> </li> <li>Continuous Integration<ul> <li>Integrate code changes frequently and automate testing to catch issues early. Continuous integration ensures the codebase is always in a deployable state.</li> </ul> </li> <li>Pragmatic Starter Kit<ul> <li>Essential practices for every project:</li> <li>Version control: Track every change.</li> <li>Issue tracking: Log and prioritize tasks and bugs.</li> <li>Testing: Write automated unit, integration, and end-to-end tests.</li> </ul> </li> </ol> </li> <li>Pragmatic Programming Techniques<ul> <li>Tracer Bullets: Implement end-to-end functionality early to guide development and test architecture.</li> <li>Spikes: Write short, disposable code to explore and solve specific problems.</li> <li>Domain Languages: Create domain-specific languages to simplify communication and development.</li> </ul> </li> </ol>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#top-takeaways-from-the-pragmatic-programmer","title":"Top Takeaways from The Pragmatic Programmer","text":"<p>Invest in Your Knowledge Portfolio Continuously learn new technologies, languages, and practices. Stay curious and adaptable.</p> <p>Communicate Clearly Be precise with requirements and documentation. Avoid ambiguity to reduce misunderstandings.</p> <p>Iterative Development Break projects into small, manageable pieces. Ship features incrementally and iterate based on feedback.</p> <p>Be a Pragmatic Problem-Solver Embrace practical solutions over theoretical perfection. Balance trade-offs to meet deadlines while maintaining quality.</p> <p>Take Responsibility Own your decisions, from code quality to project outcomes. Always strive to deliver value.</p>"},{"location":"GeneralSoftwareEngineering/PragmaticProgrammer/#conclusion","title":"Conclusion","text":"<p>\"The Pragmatic Programmer\" is more than a programming book; it\u2019s a guide to becoming a better software professional. The lessons focus on practical, real-world strategies for solving problems, working in teams, and building robust software systems. Its timeless principles are as relevant today as when the book was first published.</p> <p>By adopting the pragmatic programmer mindset, developers can create high-quality software, collaborate effectively, and continuously grow in their careers.</p>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/","title":"System Design Interview","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#overview","title":"Overview","text":"<p>System Design Interview \u2013 An Insider\u2019s Guide by Alex Xu is structured as a practical guide to help software engineers prepare for system design interviews. It demystifies complex concepts through real-world examples, explaining how to approach designing large-scale distributed systems systematically. The book emphasizes trade-offs, scalability, reliability, and maintainability.</p>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#core-themes-and-concepts","title":"Core Themes and Concepts","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#1-system-design-fundamentals","title":"1. System Design Fundamentals","text":"<p>The book begins by introducing fundamental principles that form the backbone of any system design:</p> <ul> <li> <p>Scalability: Building systems to handle increasing loads.</p> </li> <li> <p>Reliability: Ensuring system availability even under failure conditions.</p> </li> <li> <p>Maintainability: Designing systems for ease of updates and debugging.</p> </li> <li> <p>Performance: Optimizing latency and throughput.</p> </li> <li> <p>Cost-effectiveness: Balancing design choices against infrastructure costs.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#2-structured-approach-to-system-design","title":"2. Structured Approach to System Design","text":"<p>A key strength of the book is its systematic framework for tackling system design problems:</p> <ol> <li> <p>Understand the requirements: Carefully clarify functional and non-functional requirements.</p> <ul> <li> <p>Functional: Features the system must support.</p> </li> <li> <p>Non-functional: Constraints like latency, throughput, consistency, and reliability.</p> </li> </ul> </li> <li> <p>Establish the scale: Estimate the expected load, such as queries per second (QPS), storage, or traffic.</p> </li> <li> <p>Define high-level architecture: Break the system into major components, such as APIs, databases, and caching layers.</p> </li> <li> <p>Design core components: Dive deeper into the design of key elements.</p> </li> <li> <p>Address bottlenecks: Identify and solve scalability and reliability challenges.</p> </li> </ol> <p>This structure ensures a logical flow while solving open-ended system design problems.</p>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#design-patterns-and-concepts","title":"Design Patterns and Concepts","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#1-load-balancing","title":"1. Load Balancing","text":"<ul> <li> <p>Load balancers distribute incoming traffic to multiple servers to ensure even workload distribution.</p> </li> <li> <p>Key techniques:</p> <ul> <li> <p>DNS load balancing: Simple but lacks dynamic adjustment.</p> </li> <li> <p>Reverse proxies: Flexible and common in modern architectures.</p> </li> <li> <p>Health checks: Ensure failed servers are removed from the load balancer\u2019s pool.</p> </li> </ul> </li> <li> <p>Example: Designing a system for millions of concurrent users often requires multiple layers of load balancing.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#2-database-design","title":"2. Database Design","text":"<ul> <li> <p>Relational vs. NoSQL: Use relational databases for ACID compliance and NoSQL for horizontal scalability.</p> </li> <li> <p>Sharding: Splitting data across multiple databases to handle high-scale workloads.</p> <ul> <li>Techniques: Range-based, hash-based, or geo-based sharding.</li> </ul> </li> <li> <p>Replication: Ensures high availability by duplicating data across servers.</p> <ul> <li> <p>Master-slave replication: Reads are served by replicas; writes go to the master.</p> </li> <li> <p>Leaderless replication: Used in systems like DynamoDB for availability.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#3-caching","title":"3. Caching","text":"<ul> <li> <p>Caching is a vital performance optimization strategy.</p> </li> <li> <p>Types:</p> <ul> <li> <p>Client-side caching: Stored on users' devices.</p> </li> <li> <p>Server-side caching: Common solutions like Memcached or Redis.</p> </li> </ul> </li> <li> <p>Cache invalidation: Critical for maintaining consistency between the cache and the database.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#4-messaging-systems","title":"4. Messaging Systems","text":"<ul> <li> <p>Messaging systems, like Kafka or RabbitMQ, decouple components and handle asynchronous communication.</p> </li> <li> <p>Common use cases:</p> <ul> <li> <p>Data pipelines for analytics.</p> </li> <li> <p>Event-driven architectures.</p> </li> <li> <p>Buffering high-throughput write requests to the database.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#5-content-delivery-networks-cdns","title":"5. Content Delivery Networks (CDNs)","text":"<ul> <li> <p>CDNs cache static content geographically closer to users to reduce latency and bandwidth usage.</p> </li> <li> <p>Often used in systems like video streaming platforms or image-heavy websites.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#case-studies","title":"Case Studies","text":""},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#1-designing-a-url-shortener","title":"1. Designing a URL Shortener","text":"<ul> <li> <p>Requirements:</p> <ul> <li> <p>Generate short URLs.</p> </li> <li> <p>Support redirection from short URLs to original ones.</p> </li> <li> <p>Handle 100M new URLs/day and 1000 requests/second.</p> </li> </ul> </li> <li> <p>Design:</p> <ul> <li> <p>Use a hash function to generate short URLs.</p> </li> <li> <p>Store mappings in a database (e.g., NoSQL for scalability).</p> </li> <li> <p>Introduce caching to speed up redirection.</p> </li> <li> <p>Handle collisions in hash-based generation.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#2-designing-a-tinyurl-with-scalability","title":"2. Designing a TinyURL with Scalability","text":"<ul> <li> <p>Additional considerations include:</p> <ul> <li> <p>Database partitioning (sharding by hash prefix).</p> </li> <li> <p>Distributed ID generation (e.g., Snowflake algorithm) to ensure uniqueness across multiple servers.</p> </li> <li> <p>CDN for serving static resources.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#3-designing-a-social-media-news-feed","title":"3. Designing a Social Media News Feed","text":"<ul> <li> <p>Requirements:</p> <ul> <li> <p>Personalized feed for each user.</p> </li> <li> <p>High throughput for millions of users.</p> </li> </ul> </li> <li> <p>Design:</p> <ul> <li> <p>Push-based model: Pre-compute feeds for each user as posts are created.</p> </li> <li> <p>Pull-based model: Generate feeds on demand.</p> </li> <li> <p>Optimize storage with denormalization and use distributed caching for fast retrieval.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#4-designing-a-messaging-system","title":"4. Designing a Messaging System","text":"<ul> <li> <p>Requirements:</p> <ul> <li> <p>One-to-one and group messaging.</p> </li> <li> <p>Deliver messages in real-time.</p> </li> </ul> </li> <li> <p>Design:</p> <ul> <li> <p>Use a publish-subscribe model for real-time delivery.</p> </li> <li> <p>Ensure durability by persisting messages to disk.</p> </li> <li> <p>Handle offline users by queuing messages.</p> </li> </ul> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#advanced-topics","title":"Advanced Topics","text":"<p>The book goes beyond basic designs to address more complex challenges:</p> <ul> <li> <p>Consistency vs. Availability (CAP Theorem):</p> <ul> <li> <p>Understand trade-offs in distributed systems.</p> </li> <li> <p>Use eventual consistency models for systems prioritizing availability.</p> </li> </ul> </li> <li> <p>Database indexing: Improves read performance but adds write overhead.</p> </li> <li> <p>Rate limiting: Throttle requests to prevent abuse and protect backends.</p> </li> </ul>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Trade-offs are central: Every design decision involves a trade-off (e.g., latency vs. consistency, cost vs. scalability).</p> </li> <li> <p>High-level thinking matters: Interviews often test how well you can reason about complex systems, not just low-level implementation details.</p> </li> <li> <p>Practice is essential: Work through real-world scenarios to build confidence and intuition.</p> </li> </ol>"},{"location":"GeneralSoftwareEngineering/SystemDesingInterview/#why-this-book-is-valuable","title":"Why This Book is Valuable","text":"<ul> <li> <p>Clarity: Concepts are explained in simple language with visual diagrams.</p> </li> <li> <p>Practical Examples: Real-world cases like URL shorteners and newsfeeds offer hands-on learning.</p> </li> <li> <p>Interview-focused: Aimed at helping candidates succeed in system design interviews.</p> </li> </ul>"}]}