
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://shashankshet.github.io/learn-with-shashank/DataStructuresAndAlgorithms/Arrays/">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.17">
    
    
      
        <title>Arrays and strings - Learn with Shashank</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.bcfcd587.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#arrays-and-strings" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Learn with Shashank" class="md-header__button md-logo" aria-label="Learn with Shashank" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Learn with Shashank
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Arrays and strings
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Learn with Shashank" class="md-nav__button md-logo" aria-label="Learn with Shashank" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Learn with Shashank
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../developer_learning/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Developer Learning
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../generic_software_engineering/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Generic Software Engineering
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../data_structures_and_algorithms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Data Structures and Algorithms
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../miscellaneous/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Miscellaneous
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="arrays-and-strings">Arrays and strings</h1>
<p><strong>LeetCode 88: Merge Sorted Array step by step.</strong></p>
<p>üß† Problem Understanding:
You're given:
Two sorted arrays nums1 and nums2.
nums1 has extra space at the end to hold all elements from nums2.
The actual number of meaningful elements in nums1 is m.
The number of elements in nums2 is n.</p>
<p>Your task is to merge nums2 into nums1 in-place, so that nums1 becomes a fully sorted array.</p>
<p>üîç Key Insight:
Since nums1 has extra space at the end, we can fill from the back instead of the front. That way, we don‚Äôt overwrite any elements we haven‚Äôt checked yet.</p>
<p>‚úÖ Strategy:
Use three pointers:
p1 = m - 1: points to the last element in the actual nums1 values.
p2 = n - 1: points to the last element in nums2.
p = m + n - 1: points to the last position in nums1.</p>
<p>Compare elements from the back of nums1 and nums2, and place the larger one at position p.
Decrease p and whichever pointer (p1 or p2) you just used.
At the end, if any elements are left in nums2, copy them (this only happens if they are all smaller than nums1's smallest).</p>
<p>üßë‚Äçüíª Code (Python):</p>
<pre><code>
def merge(nums1, m, nums2, n):
    p1 = m - 1  # last element of nums1 (non-zero part)
    p2 = n - 1  # last element of nums2
    p = m + n - 1  # last position in nums1

    # Compare from the end
    while p1 &gt;= 0 and p2 &gt;= 0:
        if nums1[p1] &gt; nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1

    # If any elements are left in nums2
    while p2 &gt;= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
</code></pre>
<p><strong>LeetCode 27: Remove Element.</strong></p>
<p>üß† Problem Understanding
You are given:</p>
<p>An integer array nums
An integer val</p>
<p>Your task:
Remove all instances of val from the array nums, in-place
Return the count of elements that are not equal to val</p>
<p>üî∏ Constraints:</p>
<p>You don‚Äôt need to maintain the order of elements
Do it in-place (no extra space)</p>
<p>‚úÖ What You Need to Do:
Modify nums in-place such that:
The first k elements are the ones not equal to val
Return k, the number of elements not equal to val
‚ö†Ô∏è The contents beyond the first k elements don't matter.</p>
<p>üîç Strategy (Two Pointer Approach):
Use a write pointer (i) that keeps track of where to write the next non-val element.</p>
<p>Steps:
Initialize i = 0
Loop through each element num in nums
If num != val:
Write num at index i ‚Üí nums[i] = num
Increment i
At the end:
First i elements of nums are the result
Return i</p>
<p>üßë‚Äçüíª Python Code:</p>
<pre><code>def removeElement(nums, val):
    i = 0  # write pointer

    for num in nums:
        if num != val:
            nums[i] = num
            i += 1

    return i
</code></pre>
<p><strong>LeetCode 26: Remove Duplicates from Sorted Array.</strong></p>
<p>üß† Problem Summary:
Given:
A sorted integer array nums (non-decreasing order).</p>
<p>Your task:
Remove duplicates in-place such that each unique element appears only once.
Keep the relative order of the elements the same.
Return the count k of unique elements.
The first k elements in nums should be the unique values in order.</p>
<p>üîç Key Insight:
Because the array is already sorted, all duplicates will be next to each other.
We can use the two-pointer technique:
One pointer (i) keeps track of the last unique element
Another pointer (j) scans through the array</p>
<p>‚úÖ Strategy (Two Pointers):
If the array is empty, return 0.
Start with i = 0 (position to write next unique value).
Loop j from 1 to end of the array:
If nums[j] != nums[i], it means a new unique element is found.
Move i one step ahead
Copy nums[j] to nums[i]
At the end, return i + 1 (count of unique elements)</p>
<pre><code>
def removeDuplicates(nums):
    if not nums:
        return 0

    i = 0  # pointer to last unique element

    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]  # place unique element at the correct spot

    return i + 1
</code></pre>
<p><strong>Remove Duplicates from Sorted Array" problem ‚Äî this is sometimes referred to as ‚ÄúRemove Duplicates II‚Äù on LeetCode.</strong></p>
<p>üß† Problem Summary:
Given:</p>
<p>A sorted array nums (non-decreasing order).
Your task:
Modify the array in-place so that each unique element appears at most twice.
Keep the relative order the same.
Return k, the number of valid elements in the modified array (first k elements).</p>
<p>üîç Key Idea:
Since the array is sorted:
All duplicates are grouped together.
You are allowed up to 2 of each element.
We‚Äôll use the two-pointer technique again:
Pointer i is the write pointer (where to write the next valid element).
Pointer j scans through the array.</p>
<p>‚úÖ Strategy (Two Pointers with a Rule):
Initialize i = 0 (start writing from the beginning).
Loop through the array with j:
If i &lt; 2, always write nums[j] (first two elements are always allowed).
If nums[j] != nums[i - 2], then write nums[j] at nums[i].
Why i - 2? Because we‚Äôre allowing at most 2 of the same number.</p>
<p>üßë‚Äçüíª Python Code:</p>
<pre><code>def removeDuplicates(nums):
    i = 0  # write pointer

    for num in nums:
        if i &lt; 2 or num != nums[i - 2]:
            nums[i] = num
            i += 1

    return i
</code></pre>
<p><strong>Given an integer array nums, return the majority element ‚Äî the element that appears more than n//2 times.
You are guaranteed that a solution always exists.</strong></p>
<p>üß† Your Code:
python</p>
<pre><code>class Solution:
    def majorityElement(self, nums: List[int]) -&gt; int:
        counts = {}
        max_count = len(nums)//2

        for num in nums:
            if num in counts:
                counts[num] += 1
            else:
                counts[num] = 1

            if counts[num] &gt; max_count:
                return num
</code></pre>
<p>üîç Explanation:
Step 1: Initialize dictionary and threshold
python
Copy
Edit
counts = {}
max_count = len(nums) // 2
counts is a dictionary to store the frequency of each number.</p>
<p>max_count is the majority threshold. A number must appear more than this to be considered the majority element.</p>
<p>Step 2: Loop through each number
python
Copy
Edit
for num in nums:
Iterate through each element in the nums array.</p>
<p>Step 3: Count frequency of each number
python
Copy
Edit
if num in counts:
    counts[num] += 1
else:
    counts[num] = 1
If the number already exists in the dictionary, increment its count.</p>
<p>Otherwise, initialize its count to 1.</p>
<p>Step 4: Check if it's the majority
python
if counts[num] &gt; max_count:
    return num
After updating the count, check if it crossed the majority threshold.</p>
<p>If yes, return it immediately (early exit ‚Äî very efficient).</p>
<p><strong>Leetcode 189. Rotate Array step-by-step so you fully understand it.</strong>
‚úÖ Optimal Approach (O(n) Time, O(1) Space):
We can solve this in 3 simple steps using array reversals:</p>
<p>üîÅ Key Idea:
To rotate right by k:</p>
<p>Reverse the whole array</p>
<p>Reverse the first k elements</p>
<p>Reverse the remaining (n-k) elements</p>
<p>üëá Example Walkthrough:
python
Copy
Edit
nums = [1,2,3,4,5,6,7]
k = 3</p>
<p>Step 1: Reverse all ‚Üí [7,6,5,4,3,2,1]
 Step 2: Reverse first 3 ‚Üí [5,6,7,4,3,2,1]
 Step 3: Reverse rest ‚Üí [5,6,7,1,2,3,4]
Done!</p>
<p>‚úÖ Python Code:
python</p>
<pre><code>class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        n = len(nums)
        k %= n  # handle k &gt; n

        def reverse(start, end):
            while start &lt; end:
                nums[start], nums[end] = nums[end], nums[start]
                start += 1
                end -= 1

        # Step 1: Reverse the whole array
        reverse(0, n - 1)

        # Step 2: Reverse first k elements
        reverse(0, k - 1)

        # Step 3: Reverse remaining n-k elements
        reverse(k, n - 1)
</code></pre>
<p>‚úÖ Time &amp; Space Complexity:
Time: O(n)</p>
<p>Space: O(1) (in-place)</p>
<p><strong><em>Leetcode 121: Best Time to Buy and Sell Stoc</em></strong>
‚úÖ Optimal Solution (O(n) Time, O(1) Space):
üéØ Key Idea:
Track the lowest price so far (best day to buy).</p>
<p>At each day, calculate the potential profit if we sold on that day.
Keep updating the maximum profit.</p>
<p>üëá Step-by-Step Walkthrough:
python</p>
<p>prices = [7,1,5,3,6,4]</p>
<p>min_price = ‚àû
max_profit = 0</p>
<p>Day 0: price = 7 ‚Üí min_price = 7
Day 1: price = 1 ‚Üí min_price = 1
Day 2: price = 5 ‚Üí profit = 5 - 1 = 4 ‚Üí max_profit = 4
Day 3: price = 3 ‚Üí profit = 3 - 1 = 2 ‚Üí max_profit = 4
Day 4: price = 6 ‚Üí profit = 6 - 1 = 5 ‚Üí max_profit = 5 ‚úÖ
Day 5: price = 4 ‚Üí profit = 4 - 1 = 3 ‚Üí max_profit = 5</p>
<p>‚úÖ Python Code:
python</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        min_price = float('inf')  # Start with a very high price
        max_profit = 0

        for price in prices:
            if price &lt; min_price:
                min_price = price  # Update the lowest price so far
            elif price - min_price &gt; max_profit:
                max_profit = price - min_price  # Update max profit if better

        return max_profit
</code></pre>
<p>‚úÖ Time &amp; Space Complexity:
Time: O(n) ‚Üí We loop through the prices only once.</p>
<p>Space: O(1) ‚Üí No extra space used.</p>
<p><strong><em>Leetcode 122. Best Time to Buy and Sell Stock II</em></strong></p>
<p>üß† Problem Summary
You are given a list of stock prices, where prices[i] is the price on day i.
You can buy and sell as many times as you want (even on the same day), but you must sell before you buy again (you can't hold more than one share at a time).</p>
<p>Goal: Maximize your profit.</p>
<p>‚úÖ Key Insight
This problem is about taking every opportunity to make profit, no matter how small.
üëâ If the price tomorrow is higher than today, then buy today and sell tomorrow.
For example:</p>
<p>plaintext</p>
<p>prices = [7,1,5,3,6,4]
          ‚Üë ‚Üì ‚Üë ‚Üì ‚Üë ‚Üì
Opportunities to make profit:</p>
<p>Buy at 1, sell at 5 ‚Üí profit = 4
Buy at 3, sell at 6 ‚Üí profit = 3
Total profit = 4 + 3 = 7</p>
<p>üí° Greedy Approach (Simple)
python</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        profit = 0

        for i in range(1, len(prices)):
            if prices[i] &gt; prices[i - 1]:
                profit += prices[i] - prices[i - 1]

        return profit
</code></pre>
<p>üß™ Explanation
We loop from day 1 to end.</p>
<p>If today‚Äôs price (prices[i]) is greater than yesterday‚Äôs price (prices[i - 1]), it means we could‚Äôve bought yesterday and sold today.
So, we add the profit: prices[i] - prices[i - 1].
This effectively adds up all positive profit differences ‚Äî which is exactly what we want.</p>
<p>‚è±Ô∏è Time and Space Complexity
Time: O(n) ‚Äî One pass through the list.</p>
<p>Space: O(1) ‚Äî Constant space used.</p>
<p><strong><em>LeetCode 55 ‚Äì Jump Game.</em></strong>
Greedy Observation
While scanning from left to right, it is enough to know the furthest position we can reach so far.</p>
<p>Why?
Suppose we are at index i.
If the current furthest reachable index (far) is ‚â• i, we have already proven we can stand on i.
From i, the best we can do is extend far to max(far, i + nums[i]).</p>
<p>If at any time far &lt; i, we hit a ‚Äúgap‚Äù we cannot cross ‚Üí return false immediately.</p>
<p>If we finish the scan with far ‚â• last_index, then we can reach the end ‚Üí true.</p>
<p>This one-pass greedy works because earlier indices can only jump forward; once we‚Äôve computed the global maximum reach up to position i, no later step can improve reachability of any earlier gap we already failed.</p>
<p>4 Algorithm in Plain English
python</p>
<pre><code>far = 0                                # furthest index we can reach so far
for i from 0 to n-1:
    if i &gt; far:                       # gap!
        return False
    far = max(far, i + nums[i])       # extend reach
return True                            # far never dropped behind i
</code></pre>
<p>Python Implementation
python</p>
<pre><code>class Solution:
    def canJump(self, nums: list[int]) -&gt; bool:
        far = 0
        for i, step in enumerate(nums):
            if i &gt; far:                       # cannot even stand on i
                return False
            far = max(far, i + step)          # best we can do from here
            if far &gt;= len(nums) - 1:          # early exit: already at/over end
                return True
        return True
</code></pre>
<p>Complexity
Value
Time    O(n) ‚Äì one linear scan
Space   O(1) ‚Äì just the integer far</p>
<p><strong><em>LeetCode 45 ‚Äì Jump Game II in a way that makes it super intuitive to understand and solve.</em></strong></p>
<p>üß† Problem Understanding
Given:</p>
<p>An array nums, where nums[i] is the maximum jump length you can take from index i.</p>
<p>Goal:</p>
<p>Reach the last index (nums[n - 1]) using the minimum number of jumps.</p>
<p>Constraints:</p>
<p>You can reach the end (i.e., it's guaranteed).</p>
<p>From nums[i], you can jump to any nums[i + j] where 0 &lt; j ‚â§ nums[i].</p>
<p>üèÉ Real-World Analogy
Think of it like this:</p>
<p>You're standing on stones in a river, and each stone tells you how many stones forward you can jump. Your goal is to cross the river in as few jumps as possible.</p>
<p>‚úÖ Example
nums = [2, 3, 1, 1, 4]
Start at index 0:</p>
<p>You can jump to index 1 or index 2 (nums[0] = 2)</p>
<p>What's the best place to jump to?</p>
<p>Pick the one that gives you the furthest reach in the next move (greedy choice).</p>
<p>From index 1 (which has value 3), you can go to indices 2, 3, or 4.</p>
<p>So jump from 0 ‚Üí 1, then 1 ‚Üí 4.</p>
<p>Total jumps = 2</p>
<p>üí° Intuition
We use a greedy level-based BFS approach.
Each ‚Äújump‚Äù is like one level of BFS traversal.</p>
<p>Track:
currentEnd: the end of the current jump range.</p>
<p>farthest: the farthest index we can reach in the next jump.</p>
<p>Every time we reach currentEnd, we:</p>
<p>Increment jumps</p>
<p>Update currentEnd = farthest</p>
<p>‚úÖ Greedy Algorithm</p>
<pre><code>class Solution:
    def jump(self, nums: list[int]) -&gt; int:
        jumps = 0
        currentEnd = 0
        farthest = 0

        for i in range(len(nums) - 1):  # no need to jump from last index
            farthest = max(farthest, i + nums[i])
            if i == currentEnd:
                jumps += 1
                currentEnd = farthest

        return jumps

</code></pre>
<p><strong><em>H-Index problem in a very simple and clear way.</em></strong></p>
<p>üîç What is H-Index?
The H-Index is a number that measures both:
Productivity (number of papers), and
Impact (number of citations).</p>
<p>üß† Definition:
A researcher has an index h if h of their n papers have at least h citations each, and the rest of the papers have no more than h citations.</p>
<p>‚úÖ Let's break the example down:
Input: citations = [3, 0, 6, 1, 5]</p>
<p>This means:
Paper 1 has 3 citations
Paper 2 has 0
Paper 3 has 6
Paper 4 has 1
Paper 5 has 5</p>
<p>Now, we want to find the largest number h such that at least h papers have ‚â• h citations.</p>
<p>üöÄ Step-by-step Dry Run
Sort the citations in descending order:</p>
<p>[6, 5, 3, 1, 0]
Now go one by one and check:</p>
<p>At index 0: 6 citations ‚Üí at least 1 paper has ‚â• 1 citation ‚úÖ</p>
<p>At index 1: 5 citations ‚Üí at least 2 papers have ‚â• 2 citations ‚úÖ</p>
<p>At index 2: 3 citations ‚Üí at least 3 papers have ‚â• 3 citations ‚úÖ</p>
<p>At index 3: 1 citation ‚Üí at least 4 papers have ‚â• 4 citations ‚ùå (only 3 papers do)</p>
<p>‚úÖ So the highest h that satisfies the condition is 3.</p>
<p>‚úÖ Final Code (Python)</p>
<pre><code>class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        citations.sort(reverse=True)
        h = 0
        for i, c in enumerate(citations):
            if c &gt;= i + 1:
                h += 1
            else:
                break
        return h
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.1e8ae164.min.js"></script>
      
    
  </body>
</html>